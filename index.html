<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>WoodBlock Zen - Ahşap Blok Bulmaca</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
        /* Prevent scrolling when touching the game board on mobile */
        .no-scroll {
            touch-action: none;
        }
        
        body {
            overscroll-behavior: none;
            -webkit-tap-highlight-color: transparent;
        }

        /* Wood texture simulation */
        .wood-texture {
            background-color: #d4a373;
            background-image: repeating-linear-gradient(45deg, rgba(255,255,255,0.05) 0px, rgba(255,255,255,0.05) 2px, transparent 2px, transparent 4px),
                            repeating-linear-gradient(-45deg, rgba(0,0,0,0.05) 0px, rgba(0,0,0,0.05) 2px, transparent 2px, transparent 4px);
        }
        
        @keyframes bounceIn {
            0% { transform: scale(0.3); opacity: 0; }
            50% { transform: scale(1.05); opacity: 1; }
            70% { transform: scale(0.9); }
            100% { transform: scale(1); }
        }
        .animate-bounce-in {
            animation: bounceIn 0.5s cubic-bezier(0.215, 0.610, 0.355, 1.000) both;
        }
    </style>
<script type="importmap">
{
  "imports": {
    "react": "https://aistudiocdn.com/react@^19.2.0",
    "react-dom/": "https://aistudiocdn.com/react-dom@^19.2.0/",
    "react/": "https://aistudiocdn.com/react@^19.2.0/",
    "@google/genai": "https://aistudiocdn.com/@google/genai@^1.30.0",
    "lucide-react": "https://aistudiocdn.com/lucide-react@^0.554.0"
  }
}
</script>
<link rel="stylesheet" href="/index.css">
</head>
<body class="bg-stone-900 text-stone-100 font-sans antialiased overflow-hidden">
    <div id="root"></div>

    <script type="text/babel">
        // --- ICONS (SVG) ---
        const Icons = {
            Trophy: ({ size = 24, className = "" }) => (
                <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                    <path d="M6 9H4.5a2.5 2.5 0 0 1 0-5H6" />
                    <path d="M18 9h1.5a2.5 2.5 0 0 0 0-5H18" />
                    <path d="M4 22h16" />
                    <path d="M10 14.66V17c0 .55-.47.98-.97 1.21C7.85 18.75 7 20.24 7 22" />
                    <path d="M14 14.66V17c0 .55.47.98.97 1.21C16.15 18.75 17 20.24 17 22" />
                    <path d="M18 2H6v7a6 6 0 0 0 12 0V2Z" />
                </svg>
            ),
            RotateCcw: ({ size = 24, className = "" }) => (
                <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                    <path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 12" />
                    <path d="M3 3v9h9" />
                </svg>
            ),
            Volume2: ({ size = 24, className = "" }) => (
                <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                    <polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5" />
                    <path d="M15.54 8.46a5 5 0 0 1 0 7.07" />
                    <path d="M19.07 4.93a10 10 0 0 1 0 14.14" />
                </svg>
            ),
            VolumeX: ({ size = 24, className = "" }) => (
                <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                    <polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5" />
                    <line x1="23" y1="9" x2="17" y2="15" />
                    <line x1="17" y1="9" x2="23" y2="15" />
                </svg>
            )
        };

        // --- CONSTANTS ---
        const GRID_SIZE = 9;
        const PIECE_SHAPES = {
            SINGLE: [[1]],
            DOUBLE_H: [[1, 1]],
            DOUBLE_V: [[1], [1]],
            TRIPLE_H: [[1, 1, 1]],
            TRIPLE_V: [[1], [1], [1]],
            L_SHAPE: [[1, 0], [1, 0], [1, 1]],
            J_SHAPE: [[0, 1], [0, 1], [1, 1]],
            SQUARE_2x2: [[1, 1], [1, 1]],
            SQUARE_3x3: [[1, 1, 1], [1, 1, 1], [1, 1, 1]],
            T_SHAPE: [[1, 1, 1], [0, 1, 0]]
        };
        const PIECE_COLORS = [
            'bg-amber-600', 'bg-orange-600', 'bg-yellow-700', 'bg-red-800', 'bg-amber-700'
        ];
        const LEVEL_THRESHOLDS = [0, 500, 1500, 3000, 5000, 10000];

        const generateRandomPiece = () => {
            const keys = Object.keys(PIECE_SHAPES);
            const randomKey = keys[Math.floor(Math.random() * keys.length)];
            const color = PIECE_COLORS[Math.floor(Math.random() * PIECE_COLORS.length)];
            return {
                id: Math.random().toString(36).substr(2, 9),
                type: randomKey,
                shape: PIECE_SHAPES[randomKey],
                color: color
            };
        };

        const createEmptyGrid = () => Array(GRID_SIZE).fill(0).map(() => Array(GRID_SIZE).fill(0));

        // --- AUDIO UTILS ---
        let audioCtx = null;
        let bgmNodes = [];
        let nextNoteTime = 0.0;
        let isBgmPlaying = false;
        let timerID = null;
        let tempo = 60.0;
        let lookahead = 25.0;
        let scheduleAheadTime = 0.1;
        
        const NOTES = {
            'C4': 261.63, 'D4': 293.66, 'E4': 329.63, 'G4': 392.00, 'A4': 440.00,
            'C5': 523.25, 'D5': 587.33, 'E5': 659.25, 'G5': 783.99
        };
        const SCALE = [NOTES.C4, NOTES.D4, NOTES.E4, NOTES.G4, NOTES.A4, NOTES.C5, NOTES.D5, NOTES.E5];

        const getAudioContext = () => {
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            }
            return audioCtx;
        };

        const playComboSound = (comboCount) => {
            try {
                if (!isBgmPlaying && !audioCtx) return; // Only play SFX if audio is initialized/allowed or user opted in
                const ctx = getAudioContext();
                if (ctx.state === 'suspended') ctx.resume();
                
                const t = ctx.currentTime;
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                
                const baseFreq = 300 + (comboCount * 50);
                
                osc.type = 'sine';
                osc.frequency.setValueAtTime(baseFreq, t);
                osc.frequency.exponentialRampToValueAtTime(baseFreq * 0.5, t + 0.3);
                
                gain.gain.setValueAtTime(0, t);
                gain.gain.linearRampToValueAtTime(0.3 + (Math.min(comboCount, 5) * 0.05), t + 0.01);
                gain.gain.exponentialRampToValueAtTime(0.01, t + 0.4);
                
                osc.connect(gain);
                gain.connect(ctx.destination);
                
                osc.start(t);
                osc.stop(t + 0.4);

                if (comboCount > 1) {
                    const sparkOsc = ctx.createOscillator();
                    const sparkGain = ctx.createGain();
                    sparkOsc.type = 'triangle';
                    sparkOsc.frequency.setValueAtTime(baseFreq * 2, t);
                    sparkOsc.frequency.linearRampToValueAtTime(baseFreq * 3, t + 0.2);
                    sparkGain.gain.setValueAtTime(0, t);
                    sparkGain.gain.linearRampToValueAtTime(0.1, t + 0.05);
                    sparkGain.gain.exponentialRampToValueAtTime(0.01, t + 0.2);
                    sparkOsc.connect(sparkGain);
                    sparkGain.connect(ctx.destination);
                    sparkOsc.start(t);
                    sparkOsc.stop(t + 0.2);
                }
            } catch (e) {
                console.error("SFX error", e);
            }
        };

        const playNote = (freq, time, duration) => {
            if (!audioCtx) return;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = 'sine';
            osc.frequency.value = freq;
            gain.gain.setValueAtTime(0, time);
            gain.gain.linearRampToValueAtTime(0.05, time + 0.1);
            gain.gain.exponentialRampToValueAtTime(0.001, time + duration);
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.start(time);
            osc.stop(time + duration);
            bgmNodes.push(osc);
            bgmNodes.push(gain);
            setTimeout(() => {
                const i = bgmNodes.indexOf(osc);
                if (i > -1) bgmNodes.splice(i, 2);
            }, (duration + 1) * 1000);
        };

        let beatCount = 0;
        const scheduleNote = (time) => {
            if (beatCount % 4 === 0) playNote(NOTES.C4 / 2, time, 4);
            if (Math.random() > 0.3) {
                const note = SCALE[Math.floor(Math.random() * SCALE.length)];
                playNote(note, time, 1.5);
            }
            if (Math.random() > 0.7) {
                const note = SCALE[Math.floor(Math.random() * SCALE.length)];
                playNote(note, time + 0.1, 2);
            }
            beatCount++;
        };

        const scheduler = () => {
            if (!isBgmPlaying || !audioCtx) return;
            while (nextNoteTime < audioCtx.currentTime + scheduleAheadTime) {
                scheduleNote(nextNoteTime);
                nextNoteTime += 60.0 / tempo;
            }
            timerID = window.setTimeout(scheduler, lookahead);
        };

        const startBackgroundMusic = () => {
            const ctx = getAudioContext();
            if (isBgmPlaying) return;
            if (ctx.state === 'suspended') ctx.resume().catch(() => {});
            isBgmPlaying = true;
            nextNoteTime = ctx.currentTime;
            beatCount = 0;
            scheduler();
        };

        const stopBackgroundMusic = () => {
            isBgmPlaying = false;
            if (timerID) window.clearTimeout(timerID);
            bgmNodes.forEach((node) => {
                try { node.stop(); } catch(e) {}
                try { node.disconnect(); } catch(e) {}
            });
            bgmNodes = [];
        };

        // --- COMPONENTS ---

        const ParticleOverlay = ({ bursts, onComplete }) => {
            const canvasRef = React.useRef(null);
            const particles = React.useRef([]);
            const frameId = React.useRef(0);

            React.useEffect(() => {
                if (bursts.length === 0) return;
                
                bursts.forEach(burst => {
                    for (let i = 0; i < 20; i++) {
                        const angle = Math.random() * Math.PI * 2;
                        const speed = 2 + Math.random() * 4;
                        particles.current.push({
                            x: burst.x,
                            y: burst.y,
                            vx: Math.cos(angle) * speed,
                            vy: Math.sin(angle) * speed,
                            life: 1.0,
                            decay: 0.02 + Math.random() * 0.03,
                            color: burst.color,
                            size: 4 + Math.random() * 4
                        });
                    }
                });

                const animate = () => {
                    const canvas = canvasRef.current;
                    if (!canvas) return;
                    const ctx = canvas.getContext('2d');
                    if (!ctx) return;

                    ctx.clearRect(0, 0, canvas.width, canvas.height);

                    for (let i = particles.current.length - 1; i >= 0; i--) {
                        const p = particles.current[i];
                        p.x += p.vx;
                        p.y += p.vy;
                        p.life -= p.decay;
                        p.size *= 0.95;
                        if (p.life <= 0) {
                            particles.current.splice(i, 1);
                        } else {
                            ctx.beginPath();
                            ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                            ctx.fillStyle = p.color;
                            ctx.globalAlpha = p.life;
                            ctx.fill();
                        }
                    }
                    ctx.globalAlpha = 1.0;

                    if (particles.current.length > 0) {
                        frameId.current = requestAnimationFrame(animate);
                    } else {
                        onComplete();
                    }
                };

                if (canvasRef.current) {
                    canvasRef.current.width = window.innerWidth;
                    canvasRef.current.height = window.innerHeight;
                }
                animate();
                return () => {
                    cancelAnimationFrame(frameId.current);
                    particles.current = [];
                };
            }, [bursts]);

            return <canvas ref={canvasRef} className="fixed inset-0 pointer-events-none z-[1000]" />;
        };

        const BlockPiece = ({ piece, size = 'md', customCellSize, className = '', onInteract, isSelected, style }) => {
            const cellSize = customCellSize || (size === 'sm' ? 12 : size === 'md' ? 20 : 32);
            const gap = 1;
            const rows = piece.shape.length;
            const cols = piece.shape[0].length;

            return (
                <div 
                    className={`relative inline-block select-none touch-none transition-transform duration-75 ${isSelected ? 'brightness-110 drop-shadow-2xl z-50' : ''} ${className}`}
                    style={{ 
                        width: cols * cellSize + (cols - 1) * gap, 
                        height: rows * cellSize + (rows - 1) * gap,
                        ...style
                    }}
                    onPointerDown={onInteract}
                >
                    {piece.shape.map((row, rowIndex) => (
                        row.map((cell, colIndex) => {
                            if (cell === 0) return null;
                            return (
                                <div
                                    key={`${rowIndex}-${colIndex}`}
                                    className={`absolute rounded-sm border-white/20 border-t border-l shadow-sm ${piece.color}`}
                                    style={{
                                        width: cellSize,
                                        height: cellSize,
                                        top: rowIndex * (cellSize + gap),
                                        left: colIndex * (cellSize + gap),
                                        boxShadow: 'inset -2px -2px 2px rgba(0,0,0,0.2), 2px 2px 4px rgba(0,0,0,0.3)'
                                    }}
                                />
                            );
                        })
                    ))}
                </div>
            );
        };

        const GridBoard = React.forwardRef(({ grid, onCellClick, previewPlacement }, ref) => {
            const isSubgridAlt = (r, c) => {
                const boxRow = Math.floor(r / 3);
                const boxCol = Math.floor(c / 3);
                return (boxRow + boxCol) % 2 !== 0;
            };

            return (
                <div ref={ref} className="relative p-1 sm:p-2 bg-[#5d4037] rounded-lg shadow-2xl border-4 border-[#3e2723] touch-none select-none">
                    <div className="grid grid-rows-9 gap-[2px]">
                        {grid.map((row, rIndex) => (
                            <div key={rIndex} className="grid grid-cols-9 gap-[2px]">
                                {row.map((cell, cIndex) => {
                                    const isFilled = cell === 1;
                                    let isPreview = false;
                                    if (previewPlacement) {
                                        const rRel = rIndex - previewPlacement.row;
                                        const cRel = cIndex - previewPlacement.col;
                                        if (rRel >= 0 && rRel < previewPlacement.shape.length && cRel >= 0 && cRel < previewPlacement.shape[0].length && previewPlacement.shape[rRel][cRel] === 1) {
                                            isPreview = true;
                                        }
                                    }
                                    return (
                                        <div
                                            key={`${rIndex}-${cIndex}`}
                                            data-row={rIndex}
                                            data-col={cIndex}
                                            onClick={() => onCellClick && onCellClick(rIndex, cIndex)}
                                            className={`
                                                w-8 h-8 sm:w-9 sm:h-9 md:w-10 md:h-10 rounded-sm transition-colors duration-150
                                                flex items-center justify-center overflow-hidden relative
                                                ${isFilled ? 'bg-amber-600 shadow-[inset_-2px_-2px_2px_rgba(0,0,0,0.3)] border-t border-white/20' : isSubgridAlt(rIndex, cIndex) ? 'bg-[#4e342e]/80' : 'bg-[#3e2723]/60'}
                                                ${isPreview && !isFilled ? 'bg-amber-500/50' : ''}
                                            `}
                                        >
                                            {isFilled && (
                                                <div className="absolute inset-0 opacity-20" style={{
                                                    backgroundImage: `linear-gradient(45deg, rgba(0,0,0,0.1) 25%, transparent 25%, transparent 50%, rgba(0,0,0,0.1) 50%, rgba(0,0,0,0.1) 75%, transparent 75%, transparent), linear-gradient(45deg, rgba(0,0,0,0.1) 25%, transparent 25%, transparent 50%, rgba(0,0,0,0.1) 50%, rgba(0,0,0,0.1) 75%, transparent 75%, transparent)`,
                                                    backgroundSize: '4px 4px'
                                                }} />
                                            )}
                                        </div>
                                    );
                                })}
                            </div>
                        ))}
                    </div>
                </div>
            );
        });

        const GameControls = ({ score, level, highScore, onReset, isMusicOn, onToggleMusic }) => {
            return (
                <div className="w-full max-w-md mx-auto mb-4 flex flex-col gap-4">
                    <div className="flex justify-between items-center bg-[#3e2723] p-4 rounded-xl border-b-4 border-[#271815] shadow-lg">
                        <div className="flex flex-col">
                            <span className="text-[#a1887f] text-xs font-bold tracking-wider uppercase">Seviye</span>
                            <span className="text-2xl font-bold text-amber-400">{level}</span>
                        </div>
                        <div className="flex flex-col items-center">
                            <span className="text-[#a1887f] text-xs font-bold tracking-wider uppercase">Puan</span>
                            <span className="text-3xl font-black text-white tracking-widest">{score}</span>
                        </div>
                        <div className="flex flex-col items-end">
                            <span className="text-[#a1887f] text-xs font-bold tracking-wider uppercase flex items-center gap-1">
                                <Icons.Trophy size={10} /> Rekor
                            </span>
                            <span className="text-xl font-bold text-orange-200">{highScore}</span>
                        </div>
                    </div>
                    <div className="flex justify-between gap-2">
                        <button onClick={onReset} className="flex-1 bg-stone-700 hover:bg-stone-600 active:translate-y-1 border-b-4 border-stone-900 text-white py-3 rounded-lg font-bold flex items-center justify-center gap-2 transition-all">
                            <Icons.RotateCcw size={18} />
                            <span className="hidden sm:inline">Yenile</span>
                        </button>
                        <button onClick={onToggleMusic} className={`flex-1 ${isMusicOn ? 'bg-green-700 hover:bg-green-600 border-green-900' : 'bg-red-700 hover:bg-red-600 border-red-900'} active:translate-y-1 border-b-4 text-white py-3 rounded-lg font-bold flex items-center justify-center gap-2 transition-all`}>
                            {isMusicOn ? <Icons.Volume2 size={18} /> : <Icons.VolumeX size={18} />}
                            <span className="hidden sm:inline">{isMusicOn ? 'Müzik Açık' : 'Müzik Kapalı'}</span>
                        </button>
                    </div>
                </div>
            );
        };

        // Storage Keys
        const STORAGE_KEY_GAME = 'woodblock_gamestate';
        const STORAGE_KEY_MUSIC = 'woodblock_music';

        const App = () => {
            // Load persisted state
            const getInitialGameState = () => {
                try {
                    const saved = localStorage.getItem(STORAGE_KEY_GAME);
                    if (saved) {
                        const parsed = JSON.parse(saved);
                        if (!parsed.gameOver) return parsed;
                    }
                } catch(e) {
                    console.error("Failed to load game state", e);
                }
                return null;
            };

            const savedGame = getInitialGameState();

            const [grid, setGrid] = React.useState(savedGame ? savedGame.grid : createEmptyGrid());
            const [currentPieces, setCurrentPieces] = React.useState(savedGame ? savedGame.currentPieces : [generateRandomPiece(), generateRandomPiece(), generateRandomPiece()]);
            const [score, setScore] = React.useState(savedGame ? savedGame.score : 0);
            const [level, setLevel] = React.useState(savedGame ? savedGame.level : 1);
            const [highScore, setHighScore] = React.useState(() => {
                const saved = localStorage.getItem('woodblock_highscore');
                return saved ? parseInt(saved, 10) : 0;
            });
            
            const [isMusicOn, setIsMusicOn] = React.useState(() => {
                const saved = localStorage.getItem(STORAGE_KEY_MUSIC);
                return saved !== null ? JSON.parse(saved) : true; // Default true if no preference
            });

            const gridRef = React.useRef(null);
            const [dragState, setDragState] = React.useState(null);
            const [previewPlacement, setPreviewPlacement] = React.useState(null);
            const [gameOver, setGameOver] = React.useState(false);
            const [effects, setEffects] = React.useState([]);

            // Persistence Effect
            React.useEffect(() => {
                if (!gameOver) {
                    const stateToSave = {
                        grid,
                        currentPieces,
                        score,
                        level,
                        gameOver: false
                    };
                    localStorage.setItem(STORAGE_KEY_GAME, JSON.stringify(stateToSave));
                } else {
                    localStorage.removeItem(STORAGE_KEY_GAME);
                }
            }, [grid, currentPieces, score, level, gameOver]);

            // Music Persistence & Autoplay Effect
            React.useEffect(() => {
                localStorage.setItem(STORAGE_KEY_MUSIC, JSON.stringify(isMusicOn));
                if (isMusicOn) {
                    // Try to start music, might require interaction first due to browser policy
                    const ctx = getAudioContext();
                    if (ctx.state === 'suspended') {
                        const resumeAudio = () => {
                            ctx.resume().then(() => {
                                startBackgroundMusic();
                                window.removeEventListener('click', resumeAudio);
                                window.removeEventListener('touchstart', resumeAudio);
                            });
                        };
                        window.addEventListener('click', resumeAudio);
                        window.addEventListener('touchstart', resumeAudio);
                    } else {
                        startBackgroundMusic();
                    }
                } else {
                    stopBackgroundMusic();
                }
            }, [isMusicOn]);

            const toggleMusic = () => {
                setIsMusicOn(prev => !prev);
            };

            const canPlacePiece = (board, piece, row, col) => {
                const shape = piece.shape;
                const rLen = shape.length;
                const cLen = shape[0].length;
                if (row < 0 || col < 0 || row + rLen > GRID_SIZE || col + cLen > GRID_SIZE) return false;
                for (let r = 0; r < rLen; r++) {
                    for (let c = 0; c < cLen; c++) {
                        if (shape[r][c] === 1 && board[row + r][col + c] === 1) return false;
                    }
                }
                return true;
            };

            const checkMatches = (board) => {
                let newScore = 0;
                const rowsToClear = [];
                const colsToClear = [];
                const boxesToClear = [];

                for (let r = 0; r < GRID_SIZE; r++) if (board[r].every(cell => cell === 1)) rowsToClear.push(r);
                for (let c = 0; c < GRID_SIZE; c++) {
                    let full = true;
                    for (let r = 0; r < GRID_SIZE; r++) if (board[r][c] === 0) { full = false; break; }
                    if (full) colsToClear.push(c);
                }
                for (let br = 0; br < 9; br += 3) {
                    for (let bc = 0; bc < 9; bc += 3) {
                        let full = true;
                        for (let r = 0; r < 3; r++) for (let c = 0; c < 3; c++) if (board[br + r][bc + c] === 0) { full = false; break; }
                        if (full) boxesToClear.push({ r: br, c: bc });
                    }
                }

                const lines = rowsToClear.length + colsToClear.length + boxesToClear.length;
                if (lines > 0) {
                    playComboSound(lines);
                    const newEffects = [];
                    const gridRect = gridRef.current?.getBoundingClientRect();
                    if (gridRect) {
                        const cellSize = gridRect.width / 9;
                        const getCenter = (r, c) => ({ x: gridRect.left + (c * cellSize) + (cellSize / 2), y: gridRect.top + (r * cellSize) + (cellSize / 2) });
                        rowsToClear.forEach(r => newEffects.push({ ...getCenter(r, 4), color: '#f59e0b' }));
                        colsToClear.forEach(c => newEffects.push({ ...getCenter(4, c), color: '#f59e0b' }));
                        boxesToClear.forEach(box => newEffects.push({ ...getCenter(box.r + 1, box.c + 1), color: '#fbbf24' }));
                    }
                    setEffects(prev => [...prev, ...newEffects]);

                    const comboMultiplier = lines === 1 ? 1 : lines === 2 ? 3 : lines === 3 ? 6 : 10;
                    newScore += 100 * comboMultiplier;

                    const newGrid = board.map(row => [...row]);
                    rowsToClear.forEach(r => { for(let c=0; c<GRID_SIZE; c++) newGrid[r][c] = 0; });
                    colsToClear.forEach(c => { for(let r=0; r<GRID_SIZE; r++) newGrid[r][c] = 0; });
                    boxesToClear.forEach(box => { for(let r=0; r<3; r++) for(let c=0; c<3; c++) newGrid[box.r + r][box.c + c] = 0; });
                    
                    setGrid(newGrid);
                    addScore(newScore);
                }
            };

            const addScore = (points) => {
                setScore(prev => {
                    const newScore = prev + points;
                    if (newScore > highScore) {
                        setHighScore(newScore);
                        localStorage.setItem('woodblock_highscore', newScore.toString());
                    }
                    let newLevel = 1;
                    for (let i = 0; i < LEVEL_THRESHOLDS.length; i++) {
                        if (newScore >= LEVEL_THRESHOLDS[i]) newLevel = i + 1;
                    }
                    setLevel(newLevel);
                    return newScore;
                });
            };

            const checkGameOver = (board, pieces) => {
                const available = pieces.filter(p => p !== null);
                if (available.length === 0) return false;
                for (const piece of available) {
                    for (let r = 0; r < GRID_SIZE; r++) {
                        for (let c = 0; c < GRID_SIZE; c++) {
                            if (canPlacePiece(board, piece, r, c)) return false;
                        }
                    }
                }
                return true;
            };

            const handlePointerDown = (e, index) => {
                if (!currentPieces[index]) return;
                e.preventDefault();
                e.stopPropagation();
                const target = e.currentTarget;
                const rect = target.getBoundingClientRect();
                const offsetX = e.clientX - rect.left;
                const offsetY = e.clientY - rect.top;
                let gridCellSize = 32;
                if (gridRef.current) gridCellSize = gridRef.current.getBoundingClientRect().width / 9;

                setDragState({
                    isDragging: true, pieceIndex: index,
                    startPos: { x: e.clientX, y: e.clientY },
                    currentPos: { x: e.clientX, y: e.clientY },
                    dragOffset: { x: offsetX, y: offsetY },
                    gridCellSize
                });
            };

            React.useEffect(() => {
                if (!dragState) return;
                const handlePointerMove = (e) => {
                    e.preventDefault();
                    setDragState(prev => prev ? { ...prev, currentPos: { x: e.clientX, y: e.clientY } } : null);
                    if (gridRef.current && currentPieces[dragState.pieceIndex]) {
                        const gridRect = gridRef.current.getBoundingClientRect();
                        const piece = currentPieces[dragState.pieceIndex];
                        const pieceLeft = e.clientX - dragState.dragOffset.x;
                        const pieceTop = e.clientY - dragState.dragOffset.y;
                        const relativeX = pieceLeft - gridRect.left + (dragState.gridCellSize / 2);
                        const relativeY = pieceTop - gridRect.top + (dragState.gridCellSize / 2);
                        const col = Math.floor(relativeX / dragState.gridCellSize);
                        const row = Math.floor(relativeY / dragState.gridCellSize);
                        if (canPlacePiece(grid, piece, row, col)) {
                            setPreviewPlacement({ row, col, shape: piece.shape });
                        } else {
                            setPreviewPlacement(null);
                        }
                    }
                };
                const handlePointerUp = (e) => {
                    e.preventDefault();
                    if (previewPlacement && dragState && currentPieces[dragState.pieceIndex]) {
                        const piece = currentPieces[dragState.pieceIndex];
                        const { row, col } = previewPlacement;
                        const newGrid = grid.map(r => [...r]);
                        let blocksPlaced = 0;
                        for (let r = 0; r < piece.shape.length; r++) {
                            for (let c = 0; c < piece.shape[0].length; c++) {
                                if (piece.shape[r][c] === 1) {
                                    newGrid[row + r][col + c] = 1;
                                    blocksPlaced++;
                                }
                            }
                        }
                        setGrid(newGrid);
                        addScore(blocksPlaced * 10);
                        const newPieces = [...currentPieces];
                        newPieces[dragState.pieceIndex] = null;
                        setCurrentPieces(newPieces);
                        checkMatches(newGrid);
                        if (newPieces.every(p => p === null)) {
                            setTimeout(() => {
                                const nextPieces = [generateRandomPiece(), generateRandomPiece(), generateRandomPiece()];
                                setCurrentPieces(nextPieces);
                                if (checkGameOver(newGrid, nextPieces)) setGameOver(true);
                            }, 200);
                        } else {
                            if (checkGameOver(newGrid, newPieces)) setGameOver(true);
                        }
                    }
                    setDragState(null);
                    setPreviewPlacement(null);
                };
                window.addEventListener('pointermove', handlePointerMove, { passive: false });
                window.addEventListener('pointerup', handlePointerUp);
                return () => {
                    window.removeEventListener('pointermove', handlePointerMove);
                    window.removeEventListener('pointerup', handlePointerUp);
                };
            }, [dragState, grid, currentPieces, previewPlacement]);

            const handleRestart = () => {
                localStorage.removeItem(STORAGE_KEY_GAME);
                setGrid(createEmptyGrid());
                setCurrentPieces([generateRandomPiece(), generateRandomPiece(), generateRandomPiece()]);
                setScore(0);
                setLevel(1);
                setGameOver(false);
                setDragState(null);
            };

            return (
                <div className="min-h-screen wood-texture flex items-center justify-center p-4 selection:bg-transparent overflow-hidden">
                    <ParticleOverlay bursts={effects} onComplete={() => setEffects([])} />
                    <div className="max-w-lg w-full flex flex-col items-center relative">
                        <h1 className="text-3xl md:text-4xl font-black text-[#3e2723] mb-2 drop-shadow-sm tracking-tighter select-none">
                            WOODBLOCK <span className="text-amber-100">ZEN</span>
                        </h1>
                        <GameControls score={score} level={level} highScore={highScore} onReset={handleRestart} isMusicOn={isMusicOn} onToggleMusic={toggleMusic} />
                        <div className="mb-8 relative z-10">
                            <GridBoard ref={gridRef} grid={grid} previewPlacement={previewPlacement} />
                        </div>
                        <div className="w-full bg-[#3e2723]/40 p-4 rounded-xl backdrop-blur-sm min-h-[140px] flex items-center justify-center gap-4 md:gap-8 touch-none relative z-20">
                            {currentPieces.map((piece, idx) => (
                                <div key={idx} className="flex-1 flex items-center justify-center min-w-[80px] h-[100px]">
                                    {piece && (
                                        <div className={`transition-opacity duration-200 ${dragState?.pieceIndex === idx ? 'opacity-0' : 'opacity-100'}`}>
                                            <BlockPiece piece={piece} size="sm" className="cursor-grab active:cursor-grabbing hover:scale-105" onInteract={(e) => handlePointerDown(e, idx)} />
                                        </div>
                                    )}
                                </div>
                            ))}
                        </div>
                        {dragState && currentPieces[dragState.pieceIndex] && (
                            <div className="fixed pointer-events-none z-[9999]" style={{ left: dragState.currentPos.x - dragState.dragOffset.x, top: dragState.currentPos.y - dragState.dragOffset.y }}>
                                <BlockPiece piece={currentPieces[dragState.pieceIndex]} customCellSize={dragState.gridCellSize} isSelected={true} />
                            </div>
                        )}
                        <div className="mt-4 text-stone-400 text-xs text-center select-none">Blokları tahtaya sürükleyin. Puan kazanmak için satırları temizleyin.</div>
                        {gameOver && (
                            <div className="absolute inset-0 z-50 flex items-center justify-center bg-black/80 backdrop-blur-sm rounded-xl">
                                <div className="bg-white p-8 rounded-2xl text-center max-w-xs w-full shadow-2xl border-4 border-amber-600 animate-bounce-in">
                                    <h2 className="text-4xl font-black text-stone-800 mb-2">Hamle Yok!</h2>
                                    <p className="text-stone-500 mb-6">Oyun Bitti</p>
                                    <div className="text-6xl font-bold text-amber-600 mb-8">{score}</div>
                                    <button onClick={handleRestart} className="w-full bg-amber-600 text-white font-bold py-4 rounded-lg shadow-lg hover:bg-amber-500 active:scale-95 transition-all">Tekrar Oyna</button>
                                </div>
                            </div>
                        )}
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
<script type="module" src="/index.tsx"></script>
</body>
</html>